
#include <src/jaz/tomo/tomo_stack.h>
#include <src/jaz/tomo/projection/projection.h>
#include <src/jaz/tomo/membrane/blob.h>
#include <src/jaz/tomo/membrane/blob_fit.h>
#include <src/jaz/optimization/nelder_mead.h>
#include <src/jaz/optimization/lbfgs.h>
#include <src/jaz/optimization/gradient_descent.h>
#include <src/jaz/image/detection.h>
#include <src/jaz/image/similarity.h>
#include <src/jaz/image/normalization.h>
#include <src/jaz/single_particle/vtk_helper.h>
#include <src/jaz/single_particle/volume_converter.h>
#include <src/spherical-harmonics/SphericalHarmonics.h>

#include <omp.h>

using namespace gravis;
using namespace au::edu::anu::qm::ro;

void writeComFiles(std::string tiltComFn, std::string newstComFn,
				   std::string tiltComOutFn, std::string newstComOutFn,
				   std::string outFn, std::string outAli, std::string outRec);

int main(int argc, char *argv[])
{
	
	IOParser parser;
	
	const double angpix = 1.0;
	const double bin = 16.0;	
	const double fid_avg_rad = 50.0;
	
	double prior_sigma = 100.0;
	int maxBand = 2;
	
	const bool useMasks = true;
	const bool findVesicles = true;
	
	bool diag = false;
	
	double ves_min_rad, ves_max_rad, ves_spacing;
	float min_ves_CC;
	int n_threads;
	
	std::string tomoFn, tltFn, xfFn, outFn, 
			tiltComFn, newstComFn,
			tiltComOutFn, newstComOutFn,
			outAli, outRec;
			
	try
	{
		parser.setCommandLine(argc, argv);
		int gen_section = parser.addSection("General options");
		
		tomoFn = parser.getOption("--ts", "Tilt sequence image stack (e.g. *.st:mrc)", "Tomogram2_31_All_orig.st:mrc");
		tltFn = parser.getOption("--tlt", "Tilt angle file (*.tlt)", "Tomogram2_31_All.tlt");
		xfFn = parser.getOption("--xf", "Tilt sequence file (*.xf)", "Tomogram2_31_All.xf");
		
		tiltComFn = parser.getOption(
				"--tcom", "tilt.com file to be used as basis for no_vesicles_tilt.com", "tilt.com");
		tiltComOutFn = parser.getOption(
				"--otcom", "name for new tilt.com file", "no_vesicles_tilt.com");
		
		newstComFn = parser.getOption(
				"--ncom", "newst.com file to be used as basis for no_vesicles_newst.com", "newst.com");
		newstComOutFn = parser.getOption(
				"--oncom", "name for new newst.com file", "no_vesicles_newst.com");
		
		ves_min_rad = textToDouble(parser.getOption("--ves_min_rad", "Min. blob radius [pixels]", "50"));
		ves_max_rad = textToDouble(parser.getOption("--ves_max_rad", "Max. blob radius [pixels]", "150"));
		ves_spacing = textToDouble(parser.getOption("--ves_spacing", "Min. blob spacing [pixels]", "80"));
		
		min_ves_CC = textToFloat(parser.getOption("--ves_CC_thresh", "Min. std. score of CC for detection", "15"));
		
		prior_sigma = textToDouble(parser.getOption("--prior_sigma", 
				"Expected distance covered by vesicle during refinement [pixels]", "100"));
		
		maxBand = textToInteger(parser.getOption("--max_SH", 
				"Max. SH band used to model the shape", "2"));
		
		n_threads = textToInteger(parser.getOption("--j", "Number of threads", "6"));
		
		outFn = parser.getOption("--o", "Output filename", "no_vesicles.st:mrc");
		
		outAli = parser.getOption("--oa", "Output filename for aligned stack (to be generated by IMOD)", 
								  "no_vesicles.ali");
		
		outRec = parser.getOption("--or", "Output filename for tomogram (to be generated by IMOD)", 
								  "Tomogram2_31_All_no_vesicles_full.rec");
		
		diag = parser.checkOption("--diag", "Write out diagnostic information");
				
		parser.checkForErrors();
	}
	catch (RelionError XE)
	{
		parser.writeUsage(std::cout);
		std::cerr << XE;
		exit(1);
	}	
	
	writeComFiles(tiltComFn, newstComFn, tiltComOutFn, newstComOutFn, outFn, outAli, outRec);
			
	std::string ctfFn = "";
	
	const bool projectInitial = false;
	
	const bool testDetection = false;
	
	if (testDetection)
	{
		BufferedImage<float> img20;
		img20.read(tomoFn, 20);
		
		const int w = img20.xdim;
		const int h = img20.ydim;
		
		BufferedImage<float> fidKernel = Detection::smallCircleKernel<float>(10, w, h);
		BufferedImage<float> vesKernel = Detection::circleKernel<float>(50, 120, w, h);
		
		BufferedImage<float> fidCC = Similarity::CC_2D(fidKernel, img20);
		BufferedImage<float> vesCC = Similarity::CC_2D(vesKernel, img20);
		
		d3Vector orig(0.0, 0.0, 0.0);
		d3Vector step(1.0, 1.0, 1.0);
		
		fidCC.writeVtk("dev/fidCC.vtk", orig, step);
		vesCC.writeVtk("dev/vesCC.vtk", orig, step);
		
		BufferedImage<float> fidCC_dil = Resampling::downsampleMax_2D_full(fidCC, w/16, h/16);
		fidCC_dil.writeVtk("dev/fidCC_max16.vtk", orig, 16.0*step);
	
		return 0;
	}
	
	double t0 = omp_get_wtime();
			
	TomoStack<float> ts0, ts;
	
	if (diag)
	{
		int res = system("mkdir -p dev");
	}
	
	ts0 = TomoStack<float>(
		tomoFn, -1, tltFn, 
		xfFn, ctfFn, 
		angpix, 1.0);
	
	size_t fullWidth = ts0.images[0].xdim;
	size_t fullHeight = ts0.images[0].ydim;
	
	double t0a = omp_get_wtime();		
	std::cout << "loading done in " << (t0a - t0) << " sec." << std::endl;
	
	std::stringstream sts;
	sts << bin;
	
	ts = ts0.downsample(bin, n_threads, projectInitial);
	
	double t0b = omp_get_wtime();
	
	if (projectInitial)
	{
		std::cout << "downsampling done in " << (t0b - t0a) << " sec." << std::endl;
		
		int res = system("mkdir -p frames");
		ts.saveImages("frames/bin"+sts.str()+"_*.mrc");
	}
	
	double t0act = omp_get_wtime();
	
	const int w = fullWidth / bin;
	const int h = fullHeight / bin;
	const int d = 1500 / bin;
	
	const int frameCount = ts.images.size();
	
	d3Vector origin(0.0, 0.0, -1000);
	d3Vector spacing(bin);
	d3Vector diagonal(w * spacing.x, h * spacing.y, d * spacing.z);
		
	BufferedImage<float> dest(w,h,d);
	BufferedImage<float> maskDest(w,h,d);
	
	dest.fill(0.0);
	maskDest.fill(0.0);
	
	double t1 = omp_get_wtime();
		
	if (projectInitial)
	{
		RealSpaceBackprojection::backprojectRaw(
				ts, dest, maskDest, origin, spacing, n_threads,
				RealSpaceBackprojection::Linear,
				20, 20, 10.0);
		
		double t1a = omp_get_wtime();
		std::cout << "initial backprojection done in " << (t1a - t1) << " sec." << std::endl;
		
		double t2 = omp_get_wtime();
		
		// write clean tomogram into test00.vtk
		
		dest.writeVtk("test00.vtk", origin, d3Vector(spacing));
		
		double t3 = omp_get_wtime();
		std::cout << "written out in " << (t3 - t2) << " sec." << std::endl;
	}
	
	double t3 = omp_get_wtime();
	
	std::vector<BufferedImage<float>> vesCC3D(frameCount);
	
	const int w0 = ts0.images[0].xdim;
	const int h0 = ts0.images[0].ydim;
	
	
	
	std::vector<d3Vector> vesicles;
	
	if (findVesicles)
	{
		BufferedImage<float> fidKernel = Detection::smallCircleKernel<float>(fid_avg_rad, w0, h0);
		BufferedImage<float> vesKernel = Detection::circleKernel<float>(ves_min_rad, ves_max_rad, w0, h0);
			
		double t4 = omp_get_wtime();
		std::cout << "detection kernels prepared in " << (t4 - t3) << " sec." << std::endl;
			
		
		BufferedImage<tComplex<float>> fidKernelFS, vesKernelFS;
		
		FFT::FourierTransform(fidKernel, fidKernelFS);
		FFT::FourierTransform(vesKernel, vesKernelFS);
			
		#pragma omp parallel for num_threads(n_threads)
		for (int f = 0; f < frameCount; f++)
		{
			vesCC3D[f] = Similarity::CC_2D(vesKernelFS, ts0.images[f]);
		}
		
		double t5 = omp_get_wtime();
		std::cout << "2D CCs computed in " << (t5 - t4) << " sec." << std::endl;
				
		vesicles = Detection::findLocalMaxima(
			ts0, vesCC3D, origin, spacing/bin, diagonal, 
			min_ves_CC, 10000, ves_spacing, n_threads, bin, diag? "dev/" : "");
		
		std::cout << vesicles.size() << " blobs found." << std::endl;
		
		if (diag)
		{
			int f_diag = frameCount / 2;
			BufferedImage<float> imgDiag = ts0.images[f_diag];
			
			for (int i = 0; i < vesicles.size(); i++)
			{
				d4Vector pw(vesicles[i]); 
				d4Vector pf = ts0.worldToImage[f_diag] * pw;
				
				int px = (int)(pf.x + 0.5);
				int py = (int)(pf.y + 0.5);
				
				if (px >= 0 && px < imgDiag.xdim 
					&& py >= 0 && py < imgDiag.ydim)
				{
					imgDiag(px,py) = 50;
				}
			}
			
			imgDiag.write("dev/vesDet.vtk");
			vesCC3D[f_diag].write("dev/vesCC.vtk");
		}
				
		for (int i = 0; i < vesicles.size(); i++)
		{
			std::cout << "     " << i << ": " << vesicles[i] << std::endl;
		}
	}
	else
	{
		vesicles = {d3Vector(160, 2947, -606)};
	}
	
	const bool useGradient = false;
	
	double tFit0 = omp_get_wtime();
	
	for (int ves_id = 0; ves_id < vesicles.size(); ves_id++)
	{
		const int frame = 17;
		const int s = ves_max_rad;
		const int slack = 50;
		
		std::stringstream stsv;
		stsv << ves_id;
		
		std::cout << "vesicles[" << ves_id << "] = " << vesicles[ves_id] << "\n";
		
		TomoStack<float> tsVes = ts0.extractSubStack(vesicles[ves_id], 2*s + slack, 2*s + slack);
		
		if (diag)
		{
			tsVes.images[frame].write("dev/ves-"+stsv.str()+"_rad_avg_0.vtk");
		}
		
		if (diag)
		{
			Blob blob(vesicles[ves_id], s);
			std::vector<double> radAvg = blob.radialAverage(tsVes, frame);
			BufferedImage<float> radAvgProj = blob.radialAverageProjection(tsVes, frame, radAvg);
		
			radAvgProj.write("dev/ves-"+stsv.str()+"_rad_avg_1.vtk");
		}
		
		BlobFit<float> bf0(
			ts0, vesicles, ves_id, 0.5 * (ves_min_rad + ves_max_rad), 
			s, 0, useMasks, prior_sigma, n_threads);
		
		std::vector<double> initial0 = {vesicles[ves_id].x, vesicles[ves_id].y, vesicles[ves_id].z};
		
		std::vector<double> opt0;
				
		if (useGradient)
		{
			opt0 = GradientDescent::optimize(
					initial0, bf0, 0.001, 0.00001, 0.001, 200, 0.0, diag);
			
			//opt0 = LBFGS::optimize(initial0, bf0, true, 200, 1e-2, 1);
			
			return 0;
		}
		else
		{
			opt0 = NelderMead::optimize(
					initial0, bf0, 3.0, 0.05, 100, 1.0, 2.0, 0.5, 0.5, diag);
		}
		
		if (!diag)
		{
			std::cout << "           -> ";		
			
			for (int i = 0; i < 3; i++)
			{
				std::cout << opt0[i] << ", ";
			}	
			
			std::cout << std::endl;
		}
		else
		{		
			Blob blob0(opt0, s, 0);
			std::vector<double> radAvg0 = blob0.radialAverage(tsVes, frame);
			BufferedImage<float> radAvgProj0 = blob0.radialAverageProjection(tsVes, frame, radAvg0);
		
			radAvgProj0.write("dev/ves-"+stsv.str()+"_rad_avg_2_L0.vtk");
		}		
		
		for (int SH_bands = 1; SH_bands <= maxBand; SH_bands++)
		{		
			const int SH_coeffs = (SH_bands + 1) * (SH_bands + 1);
			
			BlobFit<float> bf(
				ts0, vesicles, ves_id, 0.5 * (ves_min_rad + ves_max_rad), 
				s, SH_bands, useMasks, prior_sigma, n_threads);
			
			std::vector<double> initial(SH_coeffs + 3, 0.0);
						
			for (int i = 0; i < opt0.size(); i++)
			{
				initial[i] = opt0[i];
			}
			
			std::vector<double> opt;
					
			if (useGradient)
			{
				opt = GradientDescent::optimize(
						initial, bf, 1e-3, 1e-9, 1e-3, 200, 0.0, diag); 
			}
			else
			{
				opt = NelderMead::optimize(
						initial, bf, 3.0, 0.05, 200, 1.0, 2.0, 0.5, 0.5, diag);
			}
			
			if (!diag)
			{
				std::cout << "           -> ";		
				
				for (int i = 0; i < 3; i++)
				{
					std::cout << opt[i] << ", ";
				}
				
				std::cout << "   ";
				
				for (int j = 1; j <= SH_bands; j++)
				{
					for (int i = -j; i <= j; i++)
					{
						std::cout << opt[3 + j*j + j + i] << ", ";
					}
					
					std::cout << "   ";
				}
				
				std::cout << std::endl;
			}
			else
			{
				SphericalHarmonics sh(SH_bands);
				
				Blob blob2(opt, s, &sh);
				std::vector<double> radAvg2 = blob2.radialAverage(tsVes, frame);
				BufferedImage<float> radAvgProj2 = blob2.radialAverageProjection(tsVes, frame, radAvg2);
				
				std::stringstream sts;
				sts << SH_bands;
				radAvgProj2.write("dev/ves-"+stsv.str()+"_rad_avg_2_L"+sts.str()+".vtk");
			}
			
			opt0 = opt;
		}
		
		SphericalHarmonics sh(maxBand);
		
		Blob blobOut(opt0, s, &sh);
		
		for (int f = 0; f < frameCount; f++)
		{
			blobOut.subtract(ts0, f, 50.0);
		}
		
		if (diag)
		{
			for (int f = 0; f < frameCount; f++)
			{
				blobOut.subtract(tsVes, f, 50.0);
			}
			
			if (diag)
			{
				tsVes.saveImages("dev/ves-"+stsv.str()+"_stack.vtk");
			}
		}
	}
	
	ts0.saveLike(outFn, tomoFn);
	
	double tFit1 = omp_get_wtime();
	std::cout << "vesicles estimated and subtracted in " << (tFit1 - tFit0) << " sec." << std::endl;
		
	return 0;

}

void writeComFiles(std::string tiltComFn, std::string newstComFn,
				   std::string tiltComOutFn, std::string newstComOutFn,
				   std::string outFn, std::string outAli, std::string outRec)
{
	
	std::ifstream ifsN(newstComFn);
	std::ofstream ofsN(newstComOutFn);
	
	char line[2048];
	
	while (ifsN.getline(line, 2048))
	{
		std::string s(line);
		
		if (s.rfind("InputFile") != std::string::npos)
		{
			std::string outFn_imod;
			
			if (outFn.find_first_of(":") != std::string::npos)
			{
				outFn_imod = outFn.substr(0, outFn.find_first_of(":"));
			}
			else
			{
				outFn_imod = outFn;
			}
			
			ofsN << "InputFile " << outFn_imod << "\n";
		}
		else if (s.rfind("OutputFile") != std::string::npos)
		{
			ofsN << "OutputFile " << outAli << "\n";
		}
		else
		{
			ofsN << s << "\n";
		}
	}

	std::ifstream ifsT(tiltComFn);
	std::ofstream ofsT(tiltComOutFn);
	
	while (ifsT.getline(line, 2048))
	{
		std::string s(line);
		
		if (s.rfind("InputProjections") != std::string::npos)
		{
			ofsT << "InputProjections " << outAli << "\n";
		}
		else if (s.rfind("OutputFile") != std::string::npos)
		{
			ofsT << "OutputFile " << outRec << "\n";
		}
		else
		{
			ofsT << s << "\n";
		}
	}
}
